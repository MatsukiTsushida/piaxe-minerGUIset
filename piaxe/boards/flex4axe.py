import serial
import threading
import time
import binascii

from . import qaxe

try:
    from . import coms_pb2
except:
    pass

class Flex4AxeHardware(qaxe.QaxeHardware):
    def __init__(self, config):
        # Load settings from config
        self.config = config

        self.state_power = 0;
        self.pwm1 = self.config.get('fan_speed_1', 100)

        self.reqid = 0
        self.serial_port_ctrl_lock = threading.Lock()

        # Initialize serial communication
        self._serial_port_asic = serial.Serial(
            port=self.config['serial_port_asic'],  # For GPIO serial communication use /dev/ttyS0
            baudrate=115200,    # Set baud rate to 115200
            bytesize=serial.EIGHTBITS,     # Number of data bits
            parity=serial.PARITY_NONE,     # No parity
            stopbits=serial.STOPBITS_ONE,  # Number of stop bits
            timeout=1                      # Set a read timeout
        )

        # Initialize serial communication
        self._serial_port_ctrl = serial.Serial(
            port=self.config['serial_port_ctrl'],  # For GPIO serial communication use /dev/ttyS0
            baudrate=115200,    # Set baud rate to 115200
            bytesize=serial.EIGHTBITS,     # Number of data bits
            parity=serial.PARITY_NONE,     # No parity
            stopbits=serial.STOPBITS_ONE,  # Number of stop bits
            timeout=1                      # Set a read timeout
        )

        self.set_fan_speed(0, self.pwm1)

        self._switch_power(False)
        time.sleep(1)
        self._switch_power(True)
        time.sleep(1)


    def read_temperature_and_voltage(self):
        with self.serial_port_ctrl_lock:
            resp = self._request(2, None)
            if resp is None or resp.error != 0:
                raise Exception("failed reading status!")

            status = coms_pb2.QState()
            status.ParseFromString(resp.data[1:])

            return {
                "temp": [status.temp1 * 0.0625, status.temp2 * 0.0625, status.temp3 * 0.0625, status.temp4 * 0.0625],
                "voltage": [status.domain1 * 0.95, status.domain2 * 0.95, status.domain3 * 0.95, status.domain4 * 0.95],
            }

    def _set_state(self):
        with self.serial_port_ctrl_lock:
            qcontrol = coms_pb2.QControl()
            qcontrol.pwm1 = int(min(100, self.pwm1 * 100.0))
            if self._request(1, qcontrol).error != 0:
                raise Exception("couldn't switch power!")

    def _switch_power(self, state):
        if state:
            self.power_on()
        else:
            self.shutdown()

        time.sleep(1)

    def reset_func(self):
        # reset generated by the stm32 on power on
        pass

    def power_on(self):
        with self.serial_port_ctrl_lock:
            if self._request(5, None).error != 0:
                raise Exception("error powering on qaxe!")
            time.sleep(5)

    def shutdown(self):
        with self.serial_port_ctrl_lock:
            if self._request(4, None).error != 0:
                raise Exception("error shutting down qaxe!")
            time.sleep(5)